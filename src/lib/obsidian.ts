
interface ObsidianConfig {
  vaultPath: string;
  enabled: boolean;
}

export class ObsidianIntegration {
  private config: ObsidianConfig;

  constructor(config: ObsidianConfig) {
    this.config = config;
  }

  async syncJournalEntry(entry: any): Promise<boolean> {
    if (!this.config.enabled || !this.config.vaultPath) {
      return false;
    }

    try {
      // Detect if this is a task export
      if (entry.title === 'Task Export') {
        return this.syncTaskData(entry);
      }

      // Format the entry as markdown
      const markdown = this.formatEntryAsMarkdown(entry);
      const fileName = `${entry.date}-${entry.title.replace(/[^a-zA-Z0-9]/g, '-')}.md`;
      
      console.log('Would sync to Obsidian:', { fileName, markdown });
      
      this.downloadMarkdownFile(fileName, markdown);
      
      return true;
    } catch (error) {
      console.error('Obsidian sync failed:', error);
      return false;
    }
  }

  private async syncTaskData(entry: any): Promise<boolean> {
    try {
      const tasks = JSON.parse(entry.content);
      const markdown = this.formatTasksAsMarkdown(tasks);
      const fileName = `tasks-export-${new Date().toISOString().split('T')[0]}.md`;
      
      console.log('Would sync tasks to Obsidian:', { fileName, markdown });
      
      this.downloadMarkdownFile(fileName, markdown);
      
      return true;
    } catch (error) {
      console.error('Task sync failed:', error);
      return false;
    }
  }

  private formatTasksAsMarkdown(tasks: any[]): string {
    const statusGroups = tasks.reduce((acc, task) => {
      if (!acc[task.status]) acc[task.status] = [];
      acc[task.status].push(task);
      return acc;
    }, {});

    let markdown = `---
title: Task Export
date: ${new Date().toISOString().split('T')[0]}
type: task-export
---

# Task Manager Export

**Export Date:** ${new Date().toLocaleDateString()}
**Total Tasks:** ${tasks.length}

`;

    // Add tasks by status
    Object.entries(statusGroups).forEach(([status, statusTasks]: [string, any]) => {
      markdown += `## ${status.charAt(0).toUpperCase() + status.slice(1).replace('-', ' ')}\n\n`;
      
      statusTasks.forEach((task: any) => {
        const checkBox = task.status === 'done' ? '[x]' : '[ ]';
        const priority = this.getPriorityEmoji(task.priority);
        const dueDate = task.dueDate ? ` ğŸ“… ${new Date(task.dueDate).toLocaleDateString()}` : '';
        const assignee = task.assignee ? ` ğŸ‘¤ ${task.assignee}` : '';
        const dependencies = task.dependencies && task.dependencies.length > 0 
          ? ` ğŸ”— ${task.dependencies.length} dependencies` 
          : '';

        markdown += `- ${checkBox} ${priority} **${task.title}**${dueDate}${assignee}${dependencies}\n`;
        
        if (task.description) {
          markdown += `  - ${task.description}\n`;
        }
        
        if (task.dependencies && task.dependencies.length > 0) {
          markdown += `  - Dependencies: ${task.dependencies.join(', ')}\n`;
        }
        
        markdown += '\n';
      });
    });

    markdown += `\n---\n*Generated by SelfMastery Task Manager*\n`;

    return markdown;
  }

  private formatEntryAsMarkdown(entry: any): string {
    const tags = entry.tags.map((tag: string) => `#${tag}`).join(' ');
    const moodEmoji = this.getMoodEmoji(entry.mood);
    
    return `---
title: ${entry.title}
date: ${entry.date}
mood: ${entry.mood}
tags: [${entry.tags.map((tag: string) => `"${tag}"`).join(', ')}]
---

# ${entry.title}

**Date:** ${new Date(entry.date).toLocaleDateString()}
**Mood:** ${moodEmoji} ${entry.mood}
**Tags:** ${tags}

## Content

${entry.content}

---
*Generated by SelfMastery App*
`;
  }

  private getMoodEmoji(mood: string): string {
    const moodMap: { [key: string]: string } = {
      'great': 'ğŸ˜Š',
      'good': 'ğŸ™‚',
      'okay': 'ğŸ˜',
      'bad': 'ğŸ˜”',
      'terrible': 'ğŸ˜¢',
    };
    return moodMap[mood] || 'ğŸ˜';
  }

  private getPriorityEmoji(priority: string): string {
    const priorityMap: { [key: string]: string } = {
      'high': 'ğŸ”´',
      'medium': 'ğŸŸ¡',
      'low': 'ğŸŸ¢',
    };
    return priorityMap[priority] || 'âšª';
  }

  private downloadMarkdownFile(fileName: string, content: string) {
    const blob = new Blob([content], { type: 'text/markdown' });
    const url = URL.createObjectURL(blob);
    const link = document.createElement('a');
    link.href = url;
    link.download = fileName;
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
    URL.revokeObjectURL(url);
  }

  updateConfig(config: Partial<ObsidianConfig>) {
    this.config = { ...this.config, ...config };
  }
}

export const obsidianSync = new ObsidianIntegration({
  vaultPath: '',
  enabled: false,
});
